[
  {
    "objectID": "main.html",
    "href": "main.html",
    "title": "Notebook Principal",
    "section": "",
    "text": "Contém os testes com a árvore trie, além de exemplos de compressão e decompressão\n\nfrom trie import RadixTree\nfrom lzw import *\nfrom functions import *\nimport pandas as pd\nimport time\n\n\nFunção para escrever os códigos criados num arquivo de texto\n\n\nScript de testes\n\nCompressão:\n\nCodificação de textos\nCriação de lista de códigos\nCompressão dos códigos em binário\nComparação do tamanho dos textos com os códigos binários\nTaxa de compressão\nTempo de compressão\n\nDecompressão\n\nDecompressão dos códigos binários\nDecodificação dos códigos\nComparação do texto decodificado com o arquivo original\nTempo de decompressão\n\n\n\ndef compress_data(path, files):\n    df = pd.DataFrame(\n        columns=[\n            \"Arquivo\",\n            \"Tamanho original (bits)\",\n            \"Tamanho comprimido (bits)\",\n            \"Tamanho Dicionário\",\n            \"Qtd de bits por código\",\n            \"Taxa de compressão\",\n            \"Tempo de compressão (ms)\",\n            \"Tempo Relativo (ms/kB)\",\n        ]\n    )\n    for file_name in files:\n        f = path + \"/\" + file_name\n        with open(f, \"r\", encoding=\"utf-8\") as file:\n            s = file.read()\n            file_size = len(s)\n            print(\"-\" * 50)\n            print(f\"Arquivo de entrada: {file_name}\")\n            print(f\"Tamanho: {len(s)} bytes\")\n            print(\"-\" * 50)\n            # Repete 20 vezes\n            n_loops = 20\n            for i in range(n_loops):\n                print(f\"Encode start: ({i+1}/{n_loops})\")\n                # Codificação\n                start_time = time.monotonic_ns()\n                encoder = LZW_Encoder(by=format)\n                encoded = encoder.encode(s)\n                compressed, n_bits = compress(encoded)\n                end_time = time.monotonic_ns()\n                # Fim da codificação\n\n                dictionary = encoder.dictionary\n                dict_size = len(dictionary)\n                compressed_size = len(compressed)\n                compressed_rate = file_size / compressed_size\n                code_time = (end_time - start_time) / 1_000_000\n                rel_time = code_time / file_size\n                print(f\"Encode end: {code_time} ms\")\n\n                # Dataframe\n                df.loc[len(df)] = [\n                    file_name,  # Nome do arquivo\n                    8 * file_size,  # Tamanho em bits\n                    len(compressed),  # Tamanho em bits\n                    dict_size,  # Número de strings\n                    n_bits,  # Bits por código\n                    8 * compressed_rate,  # Taxa de compressão\n                    code_time,  # Tempo em ms\n                    1024 * rel_time,  # Tempo relativo em ms/kB\n                ]\n    return df\n\n\ndef main():\n    \"\"\"\n    Exemplo de uso.\n    \"\"\"\n    # Arquivos de entrada\n    n_files = 4\n    path = \"tests\"\n    files = [f\"ex ({i}).txt\" for i in range(1, n_files + 1)]  # \"ex (i).txt\"\n    files.append(\"functions.py\")\n    files.append(\"lzw.py\")\n    files.append(\"trie.py\")\n    # Criação do Dataframe\n    df = compress_data(path, files)\n    print(df)\n    df.to_csv(\"out.csv\", index=False)\n\n\nif __name__ == \"__main__\":\n    main()\n\n--------------------------------------------------\nArquivo de entrada: ex (1).txt\nTamanho: 18 bytes\n--------------------------------------------------\nEncode start: (1/20)\nEncode end: 0.421227 ms\nEncode start: (2/20)\nEncode end: 0.33242 ms\nEncode start: (3/20)\nEncode end: 0.983119 ms\nEncode start: (4/20)\nEncode end: 0.363589 ms\nEncode start: (5/20)\nEncode end: 0.293871 ms\nEncode start: (6/20)\nEncode end: 0.295811 ms\nEncode start: (7/20)\nEncode end: 0.293191 ms\nEncode start: (8/20)\nEncode end: 0.28954 ms\nEncode start: (9/20)\nEncode end: 0.332359 ms\nEncode start: (10/20)\nEncode end: 0.32512 ms\nEncode start: (11/20)\nEncode end: 0.29473 ms\nEncode start: (12/20)\nEncode end: 0.30209 ms\nEncode start: (13/20)\nEncode end: 0.290891 ms\nEncode start: (14/20)\nEncode end: 0.290501 ms\nEncode start: (15/20)\nEncode end: 0.31235 ms\nEncode start: (16/20)\nEncode end: 0.294631 ms\nEncode start: (17/20)\nEncode end: 0.294221 ms\nEncode start: (18/20)\nEncode end: 0.294341 ms\nEncode start: (19/20)\nEncode end: 0.370848 ms\nEncode start: (20/20)\nEncode end: 0.300791 ms\n--------------------------------------------------\nArquivo de entrada: ex (2).txt\nTamanho: 11743 bytes\n--------------------------------------------------\nEncode start: (1/20)\nEncode end: 48.311475 ms\nEncode start: (2/20)\nEncode end: 51.231582 ms\nEncode start: (3/20)\nEncode end: 49.671858 ms\nEncode start: (4/20)\nEncode end: 51.380493 ms\nEncode start: (5/20)\nEncode end: 47.987965 ms\nEncode start: (6/20)\nEncode end: 65.70974 ms\nEncode start: (7/20)\nEncode end: 51.467085 ms\nEncode start: (8/20)\nEncode end: 49.526107 ms\nEncode start: (9/20)\nEncode end: 56.226188 ms\nEncode start: (10/20)\nEncode end: 48.838534 ms\nEncode start: (11/20)\nEncode end: 59.536606 ms\nEncode start: (12/20)\nEncode end: 51.245624 ms\nEncode start: (13/20)\nEncode end: 50.430165 ms\nEncode start: (14/20)\nEncode end: 53.55974 ms\nEncode start: (15/20)\nEncode end: 47.494669 ms\nEncode start: (16/20)\nEncode end: 65.257262 ms\nEncode start: (17/20)\nEncode end: 51.129237 ms\nEncode start: (18/20)\nEncode end: 55.370643 ms\nEncode start: (19/20)\nEncode end: 62.755672 ms\nEncode start: (20/20)\nEncode end: 51.759708 ms\n--------------------------------------------------\nArquivo de entrada: ex (3).txt\nTamanho: 8971 bytes\n--------------------------------------------------\nEncode start: (1/20)\nEncode end: 36.740512 ms\nEncode start: (2/20)\nEncode end: 31.775135 ms\nEncode start: (3/20)\nEncode end: 33.928508 ms\nEncode start: (4/20)\nEncode end: 34.066216 ms\nEncode start: (5/20)\nEncode end: 48.935378 ms\nEncode start: (6/20)\nEncode end: 35.413554 ms\nEncode start: (7/20)\nEncode end: 32.189599 ms\nEncode start: (8/20)\nEncode end: 31.673038 ms\nEncode start: (9/20)\nEncode end: 32.199432 ms\nEncode start: (10/20)\nEncode end: 34.978595 ms\nEncode start: (11/20)\nEncode end: 36.727479 ms\nEncode start: (12/20)\nEncode end: 39.124328 ms\nEncode start: (13/20)\nEncode end: 34.51859 ms\nEncode start: (14/20)\nEncode end: 50.001666 ms\nEncode start: (15/20)\nEncode end: 33.397616 ms\nEncode start: (16/20)\nEncode end: 32.458646 ms\nEncode start: (17/20)\nEncode end: 31.771168 ms\nEncode start: (18/20)\nEncode end: 35.023193 ms\nEncode start: (19/20)\nEncode end: 31.772918 ms\nEncode start: (20/20)\nEncode end: 32.815585 ms\n--------------------------------------------------\nArquivo de entrada: ex (4).txt\nTamanho: 2052 bytes\n--------------------------------------------------\nEncode start: (1/20)\nEncode end: 13.513721 ms\nEncode start: (2/20)\nEncode end: 13.947618 ms\nEncode start: (3/20)\nEncode end: 13.493161 ms\nEncode start: (4/20)\nEncode end: 13.794832 ms\nEncode start: (5/20)\nEncode end: 13.961286 ms\nEncode start: (6/20)\nEncode end: 13.971166 ms\nEncode start: (7/20)\nEncode end: 13.679137 ms\nEncode start: (8/20)\nEncode end: 13.889858 ms\nEncode start: (9/20)\nEncode end: 16.258022 ms\nEncode start: (10/20)\nEncode end: 14.250553 ms\nEncode start: (11/20)\nEncode end: 13.962016 ms\nEncode start: (12/20)\nEncode end: 14.444196 ms\nEncode start: (13/20)\nEncode end: 14.43342 ms\nEncode start: (14/20)\nEncode end: 14.364844 ms\nEncode start: (15/20)\nEncode end: 13.892274 ms\nEncode start: (16/20)\nEncode end: 13.789216 ms\nEncode start: (17/20)\nEncode end: 17.526332 ms\nEncode start: (18/20)\nEncode end: 19.492316 ms\nEncode start: (19/20)\nEncode end: 14.393454 ms\nEncode start: (20/20)\nEncode end: 14.572427 ms\n--------------------------------------------------\nArquivo de entrada: functions.py\nTamanho: 3053 bytes\n--------------------------------------------------\nEncode start: (1/20)\nEncode end: 13.921113 ms\nEncode start: (2/20)\nEncode end: 12.007911 ms\nEncode start: (3/20)\nEncode end: 34.384233 ms\nEncode start: (4/20)\nEncode end: 11.074481 ms\nEncode start: (5/20)\nEncode end: 11.143669 ms\nEncode start: (6/20)\nEncode end: 10.811107 ms\nEncode start: (7/20)\nEncode end: 11.217007 ms\nEncode start: (8/20)\nEncode end: 11.179018 ms\nEncode start: (9/20)\nEncode end: 11.558914 ms\nEncode start: (10/20)\nEncode end: 11.404191 ms\nEncode start: (11/20)\nEncode end: 11.277639 ms\nEncode start: (12/20)\nEncode end: 10.78496 ms\nEncode start: (13/20)\nEncode end: 11.025561 ms\nEncode start: (14/20)\nEncode end: 11.669857 ms\nEncode start: (15/20)\nEncode end: 11.476918 ms\nEncode start: (16/20)\nEncode end: 11.731309 ms\nEncode start: (17/20)\nEncode end: 11.490282 ms\nEncode start: (18/20)\nEncode end: 10.763871 ms\nEncode start: (19/20)\nEncode end: 11.529775 ms\nEncode start: (20/20)\nEncode end: 10.950115 ms\n--------------------------------------------------\nArquivo de entrada: lzw.py\nTamanho: 3627 bytes\n--------------------------------------------------\nEncode start: (1/20)\nEncode end: 16.529909 ms\nEncode start: (2/20)\nEncode end: 15.080859 ms\nEncode start: (3/20)\nEncode end: 15.764029 ms\nEncode start: (4/20)\nEncode end: 14.44583 ms\nEncode start: (5/20)\nEncode end: 28.843409 ms\nEncode start: (6/20)\nEncode end: 14.183998 ms\nEncode start: (7/20)\nEncode end: 14.389654 ms\nEncode start: (8/20)\nEncode end: 14.034774 ms\nEncode start: (9/20)\nEncode end: 14.368203 ms\nEncode start: (10/20)\nEncode end: 14.524151 ms\nEncode start: (11/20)\nEncode end: 14.308417 ms\nEncode start: (12/20)\nEncode end: 13.96307 ms\nEncode start: (13/20)\nEncode end: 14.648257 ms\nEncode start: (14/20)\nEncode end: 14.680564 ms\nEncode start: (15/20)\nEncode end: 14.753923 ms\nEncode start: (16/20)\nEncode end: 14.572163 ms\nEncode start: (17/20)\nEncode end: 14.774733 ms\nEncode start: (18/20)\nEncode end: 19.103614 ms\nEncode start: (19/20)\nEncode end: 16.64832 ms\nEncode start: (20/20)\nEncode end: 14.651567 ms\n--------------------------------------------------\nArquivo de entrada: trie.py\nTamanho: 12424 bytes\n--------------------------------------------------\nEncode start: (1/20)\nEncode end: 57.330306 ms\nEncode start: (2/20)\nEncode end: 54.54507 ms\nEncode start: (3/20)\nEncode end: 71.110143 ms\nEncode start: (4/20)\nEncode end: 52.496038 ms\nEncode start: (5/20)\nEncode end: 55.449839 ms\nEncode start: (6/20)\nEncode end: 52.682682 ms\nEncode start: (7/20)\nEncode end: 55.967342 ms\nEncode start: (8/20)\nEncode end: 51.165711 ms\nEncode start: (9/20)\nEncode end: 52.60853 ms\nEncode start: (10/20)\nEncode end: 56.942974 ms\nEncode start: (11/20)\nEncode end: 58.138041 ms\nEncode start: (12/20)\nEncode end: 59.105188 ms\nEncode start: (13/20)\nEncode end: 71.97067 ms\nEncode start: (14/20)\nEncode end: 54.36398 ms\nEncode start: (15/20)\nEncode end: 52.687624 ms\nEncode start: (16/20)\nEncode end: 51.57469 ms\nEncode start: (17/20)\nEncode end: 52.92322 ms\nEncode start: (18/20)\nEncode end: 54.921539 ms\nEncode start: (19/20)\nEncode end: 54.346404 ms\nEncode start: (20/20)\nEncode end: 53.41289 ms\n        Arquivo  Tamanho original (bits)  Tamanho comprimido (bits)  \\\n0    ex (1).txt                      144                        144   \n1    ex (1).txt                      144                        144   \n2    ex (1).txt                      144                        144   \n3    ex (1).txt                      144                        144   \n4    ex (1).txt                      144                        144   \n..          ...                      ...                        ...   \n135     trie.py                    99392                      38316   \n136     trie.py                    99392                      38316   \n137     trie.py                    99392                      38316   \n138     trie.py                    99392                      38316   \n139     trie.py                    99392                      38316   \n\n     Tamanho Dicionário  Qtd de bits por código  Taxa de compressão  \\\n0                   271                       9            1.000000   \n1                   271                       9            1.000000   \n2                   271                       9            1.000000   \n3                   271                       9            1.000000   \n4                   271                       9            1.000000   \n..                  ...                     ...                 ...   \n135                3448                      12            2.594008   \n136                3448                      12            2.594008   \n137                3448                      12            2.594008   \n138                3448                      12            2.594008   \n139                3448                      12            2.594008   \n\n     Tempo de compressão (ms)  Tempo Relativo (ms/kB)  \n0                    0.421227               23.963136  \n1                    0.332420               18.911004  \n2                    0.983119               55.928548  \n3                    0.363589               20.684174  \n4                    0.293871               16.717995  \n..                        ...                     ...  \n135                 51.574690                4.250844  \n136                 52.923220                4.361991  \n137                 54.921539                4.526695  \n138                 54.346404                4.479292  \n139                 53.412890                4.402350  \n\n[140 rows x 8 columns]\n\n\n\n\nTestes de Decodificação\n\nfiles = [\"ex (3).txt\", \"functions.py\", \"trie.py\"]\nencoder = LZW_Encoder()\ndecoder = LZW_Decoder()\nfor file_name in files:\n    with open(\"tests/\" + file_name, \"r\", encoding=\"utf-8\") as file:\n        s = file.read()\n        encoded = encoder.encode(s)\n        compressed, n_bits = compress(encoded)\n        decoded = decompress(compressed, n_bits)\n        text = decoder.decode(decoded)\n        print(\"-\" * 50)\n        print(file_name)\n        print(\"-\" * 50)\n        print(text)\n        print(\"\\n\")\n\n--------------------------------------------------\nex (3).txt\n--------------------------------------------------\nUNIVERSIDADE FEDERAL DE MINAS GERAIS\nInstituto de Ciências Exatas\nDepartamento de Ciência da Computação\n\nDCC207 -- Algoritmos 2\nProf. Renato Vimieiro\n\nTrabalho Prático 1 -- Manipulação de sequências\n\nObjetivos\n\nNesse trabalho serão abordados os aspectos práticos de manipulação de sequências. Especificamente, serão explorados aspectos de implementação de árvores de prefixo aplicada ao problema de compressão de arquivos.\n\nO objetivo secundário é fixar o conteúdo. Entende-se que ao implementar a estrutura o aluno conseguirá compreender melhor os conceitos explorados. Dessa forma, o conteúdo teórico será melhor absorvido e fixado. Além disso, os alunos terão a oportunidade de ver conceitos não abordados na disciplina, no caso específico, um método de compressão de arquivos.\n\nTarefas\n\nOs alunos deverão implementar um algoritmo para resolver o problema de \ncompressão de arquivos através do método Lempel-Ziv-Welch (LZW). Esse método é baseado em dicionários e, basicamente, substitui strings que se repetem no texto por códigos. Como o algoritmo executa muitas buscas e inserções nesse dicionário, é comum utilizar árvores de prefixo na sua implementação, como discutido por Salomon em seu livro (ver referências). O LZW, apesar de simples, é utilizado em várias ferramentas de compressão, e em alguns tipos de arquivo. O exemplo mais conhecido, talvez, é o formato GIF que utiliza o algoritmo na compressão das imagens. O método foi patenteado e houve muita discussão no passado sobre seu uso na transmissão de imagens via internet. Dada sua eficiência e apelo prático, estudaremos esse algoritmo no trabalho prático, com o foco na sua implementação, mais precisamente, em como as estruturas vistas em sala podem ser usadas para viabilizar o algoritmo. A seguir é apresentada uma breve descrição do LZW e da tarefa.\n\nO LZW foi proposto por Terry Welch em 1984 como uma implementação eficiente do método LZ78 proposto por Lempel e Ziv em 1978. Como dito, a ideia central do algoritmo é substituir strings que se repetem no texto por códigos, diminuindo assim o número de bytes gravados na saída. O algoritmo inicia gerando um dicionário contendo o código para todos os símbolos do alfabeto em questão. Conforme a proposta original, esse dicionário possui inicialmente 256 entradas referentes aos símbolos da tabela ASCII. Em seguida, o algoritmo consome símbolos do arquivo de entrada um-a-um. Ao ler um novo símbolo x, o algoritmo concatena x a uma string I, lida anteriormente, e verifica se a string Ix já foi armazenada no dicionário. Caso ela já tenha sido armazenada, o algoritmo atualiza a string I com a nova string Ix, e repete o processo. Caso a string Ix não tenha sido armazenada ainda, o algoritmo imprime o código referente a I no arquivo de saída, insere a string Ix associada a um novo código (sequencial) no dicionário, atualiza I com x, e repete o processo. Esse processo é \nrepetido enquanto ainda houver símbolos na entrada.\n\nA descompressão segue um processo análogo. O dicionário agora é inicializado com códigos associados aos símbolos do alfabeto. O algoritmo então consome códigos do arquivo de entrada (comprimido) um-a-um. Ao ler um código, o algoritmo verifica se esse já foi inserido no dicionário. Caso tenha sido, o primeiro símbolo dessa string é concatenado a string anterior, o resultado é adicionado ao dicionário, caso já não esteja, e impresso na saída. Finalmente, a string anterior é atualizada com a string \nrecuperado pelo código e o processo se repete. Caso o código não esteja no dicionário, a string é concatenada ao seu primeiro símbolo, o resultado é adicionado ao dicionário e impresso na saída.\n\nUma descrição mais detalhada dos processos de compressão e descompressão pode ser obtida nas referências listadas ao final desse documento.\n\nO código usado no LZW pode ter tamanho fixo ou variável. Em implementações com tamanho fixo, o número de bits usados é fixado antes do início da compressão. Essa é a abordagem proposta inicialmente para implementar o algoritmo. Sua intenção era limitar o uso de memória pelo algoritmo, já que, o tamanho do dicionário fica limitado ao número máximo de códigos possíveis. Usualmente, eram usados 12 bits na codificação, mas há implementações mais recentes com 15 ou 16 bits. Outra possibilidade é usar uma implementação com tamanho variável. Nesse caso, inicia-se a compressão com 9 bits (a tabela de códigos iniciais é fixa em 8 bits pela codificação \nASCII) e o tamanho é incrementado bit a bit à medida que mais códigos são \nnecessários. Em implementações de tamanho variável também se adota um tamanho máximo para o número de bits pelas mesmas razões da abordagem fixa. É importante lembrar que, nesse caso, o decodificador deve estar atento às mudanças de tamanho do código durante a leitura dos mesmos.\n\nOutro ponto em relação à implementação do algoritmo diz respeito à escolha da estrutura de dados utilizada para o dicionário. Diversos trabalhos apontam que a implementação se beneficia de árvores de prefixo (Tries) para essa função.\nNesse trabalho, você deverá implementar as duas versões do algoritmo LZW discutidas acima. As implementações podem ser feitas em C/C++ ou Python (preferencialmente). Além da implementação do codificador e decodificador do LZW, você também deverá implementar o dicionário usado pelos métodos. Sua implementação deve ser a de uma árvore de prefixo. Como o codificador associa string -&gt; inteiro, e o decodificador inteiro -&gt; string, você deverá implementar uma trie compacta baseada nas strings binárias dos códigos ou texto. As implementações das árvores devem ser completas, incluindo pesquisa, inclusões e remoções de elementos.\n\nSua implementação deverá receber os parâmetros pela linha de comando (como \nmétodos no Linux). Caso o número de bits máximo não seja informado (parâmetro opcional), deve-se assumir o padrão de 12 bits em ambas as versões. No caso da versão de tamanho fixo, esse é o tamanho fixo a ser usado.\n\nVocê também deverá implementar uma opção de teste em que o programa \narmazenará estatísticas da codificação/decodificação. Essas estatísticas deverão conter a taxa de compressão ao longo do processamento dos arquivos, tamanho do dicionário (número de elementos armazenados e espaço em memória), tempo total de execução, e outras estatísticas que você julgar importantes. Essas estatísticas deverão ser processadas por um outro script que irá gerar um relatório (gráficos, tabelas, etc.) do processo.\n\nPor fim, você deverá realizar testes de funcionamento e desempenho do método implementado com diferentes tipos de dados. Deverão ser usados arquivos texto, imagens (em bitmap) e qualquer outro formato de entrada não comprimido para avaliar o algoritmo. Deverão ser gerados os relatórios como descrito no parágrafo anterior. Esses relatórios serão agregados e analisados em um relatório final.\n\nO relatório final deve ser feito em formato de página/blog e deverá ser publicado junto com o código em repositório aberto no GitHub. O relatório deverá conter uma explicação com a suas palavras sobre os métodos e as implementações. Deverão ser dados exemplos de funcionamento de compressão e descompressão de texto. Você também deve apresentar a análise dos resultados obtidos com os testes realizados. O nível de elaboração do texto e qualidade das análises serão critérios de avaliação. Em outras palavras, o mesmo cuidado com a implementação deverá ser observado nos testes realizados e no relatório produzido.\n\nO trabalho poderá ser feito em grupos de até dois alunos.\n\nO que entregar?\n\nDeverá ser entregue um repositório no GitHub contendo todos os arquivos criados na implementação da ferramenta, bem como exemplos usados na explicação. O link para o repositório deverá ser postado no Moodle. O repositório deverá ser mantido privado até 3 dias após a data de entrega. Então, o repositório deverá ser tornado público. Caso a qualidade do trabalho exceda às expectativas do professor, pontos extras \npoderão ser atribuídos.\n\nPolítica de Plágio \n\nOs alunos podem, e devem, discutir soluções sempre que necessário. Dito isso, há uma diferença bem grande entre implementação de soluções similares e cópia integral de ideias. Trabalhos copiados na íntegra ou em partes de outros alunos e/ou da internet serão prontamente anulados. Caso haja dois trabalhos copiados por alunos/grupos diferentes, ambos serão anulados. \n\nDatas\n\nEntrega: 19/11/2024 às 23h59\n\nPolítica de atraso\n\nHaverá tolerância de 30min na entrega dos trabalhos. Submissões feitas depois do intervalo de tolerância serão penalizados, incluindo mudanças no repositório.\n- Atraso de 1 dia: 30%\n- Atraso de 2 dias: 50%\n- Atraso de 3+ dias: não aceito\n\nSerão considerados atrasos de 1 dia aqueles feitos após as 0h30 do dia seguinte à entrega (sexta-feira). A partir daí serão contados o número de dias passados da data de entrega.\n\nReferências\n- https://web.mit.edu/6.02/www/s2012/handouts/3.pdf\n- https://www.davidsalomon.name/DC4advertis/DComp4Ad.html\n\n\n--------------------------------------------------\nfunctions.py\n--------------------------------------------------\nfrom lzw import *\n\n\ndef str_to_bin(s: str):\n    \"\"\"\n    Converte uma string em ASCII para uma string binária.\n\n    Args:\n        s (str): A string a ser convertida.\n\n    Returns:\n        bin (str): A string binária.\n    \"\"\"\n    bin = \"\"\n    for c in s:\n        bin += format(ord(c), \"b\").zfill(8)\n    return bin\n\n\ndef bin_to_str(bin: str):\n    \"\"\"\n    Converte uma string binária para uma string em ASCII.\n\n    Args:\n        bin (str): A string binária a ser convertida.\n\n    Returns:\n        s (str): A string em ASCII.\n    \"\"\"\n    s = \"\"\n    for i in range(0, len(bin), 8):\n        s += chr(int(bin[i : i + 8], 2))\n    return s\n\n\ndef compress(codes_list: list[int], max_bits: int = None) -&gt; tuple[str, int]:\n    \"\"\"\n    Comprime uma lista de códigos.\n\n    Args:\n        codes_list (list[int]): A lista de códigos.\n        max_bits (int): O número máximo de bits.\n        Se None, o número máximo de bits é calculado automaticamente.\n\n    Returns:\n        bin (str): A string binária compacta.\n        max_bits (int): O número máximo de bits.\n    \"\"\"\n    if max_bits == None:\n        max_bits = max(codes_list).bit_length()\n    bin = \"\"\n    for i in codes_list:\n        bin += format(i, \"b\").zfill(max_bits)\n    return bin, max_bits\n\n\ndef decompress(bin: str, n_bits: int) -&gt; list[int]:\n    \"\"\"\n    Descomprime uma string binária.\n\n    Args:\n        bin (str): A string binária a ser descompactada.\n        n_bits (int): O número de bits por código.\n\n    Returns:\n        codes_list (list[int]): A lista de códigos.\n    \"\"\"\n    codes_list = []\n    for i in range(0, len(bin), n_bits):\n        codes_list.append(int(bin[i : i + n_bits], 2))\n    return codes_list\n\n\ndef encoder(text: str, by: str = \"binary\") -&gt; tuple[str, int]:\n    \"\"\"\n    Compacta um texto.\n\n    Args:\n        text (str): Texto a ser compactado.\n        by (str): 'binary' ou 'ascii'\n\n    Returns:\n        compressed (str): Texto compactado\n        n_bits (int): O número de bits.\n    \"\"\"\n    print(f\"Encoding {by} text...\")\n    encoder = LZW_Encoder(by=by)\n    t = text\n    if by == \"binary\":\n        t = str_to_bin(t)\n\n    encoded = encoder.encode(t)\n    compressed, n_bits = compress(encoded)\n    print(f\"Original Size:     {len(text)*8} bits\")\n    print(f\"Compressed Size:   {len(compressed)} bits\")\n    print(f\"Compression Ratio: {len(text)*8/len(compressed)}\")\n    return compressed, n_bits\n\n\ndef decoder(codes: str, n_bits: int, by: str = \"binary\") -&gt; str:\n    \"\"\"\n    Descompacta um texto.\n\n    Args:\n        codes (str): Texto compactado.\n        n_bits (int): Número de bits por código.\n        by (str): 'binary' ou 'ascii'\n\n    Returns:\n        decoded (str): Texto descompactado.\n    \"\"\"\n    print(f\"Decoding {by} text...\")\n    decoder = LZW_Decoder(by=by)\n    c = decompress(codes, n_bits)\n    decoded = decoder.decode(c)\n    if by == \"binary\":\n        decoded = bin_to_str(decoded)\n    print(f\"Compressed Size:   {len(codes)} bits\")\n    print(f\"Original Size:     {len(decoded)*8} bits\")\n    print(f\"Compression Ratio: {(len(decoded)*8)/len(codes)}\")\n    return decoded\n\n\n\n--------------------------------------------------\ntrie.py\n--------------------------------------------------\nclass RadixTree:\n    \"\"\"\n    Uma árvore de prefixos compacta.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Cria uma árvore de prefixos compacta vazia.\n        &gt;&gt;&gt; RadixTree()\n        \"\"\"\n        # O nó raiz da árvore\n        self.root = RadixNode()\n        # O número de palavras na árvore\n        self.size = 0\n        # Próximo índice\n        self.next_index = 0\n\n    def insert(self, word: str) -&gt; None:\n        \"\"\"\n        Insere uma palavra na árvore.\n\n        Args:\n            word (str): palavra a ser inserida.\n\n        &gt;&gt;&gt; RadixTree().insert(\"word\")\n        \"\"\"\n        index = self.next_index\n        self.root.insert(word, index)\n        self.next_index += 1\n        self.size += 1\n\n    def insert_many(self, words: list[str]) -&gt; None:\n        \"\"\"\n        Insere várias palavras na árvore.\n\n        Args:\n            words (list[str]): lista de palavras a serem inseridas.\n\n        &gt;&gt;&gt; RadixTree().insert_many([\"word1\", \"word2\"])\n        \"\"\"\n        for word in words:\n            self.insert(word)\n\n    def find(self, word: str) -&gt; tuple[bool, int]:\n        \"\"\"\n        Verifica se uma palavra está na árvore e retorna seu índice.\n\n        Args:\n            word (str): palavra a ser verificada.\n\n        Returns:\n            bool: True se a palavra estiver na árvore,\n                  False caso contrário.\n            int: Índice da palavra,\n                 -1 caso a palavra não encontrada.\n\n        &gt;&gt;&gt; RadixTree().insert(\"word\")\n        &gt;&gt;&gt; RadixTree().find(\"word\")\n        (True, 0)\n        \"\"\"\n        return self.root.find(word)\n\n    def index(self, word: str) -&gt; int:\n        \"\"\"\n        Retorna o índice de uma palavra na árvore.\n\n        Args:\n            word (str): palavra a ser verificada.\n\n        Returns:\n            int: índice da palavra na árvore.\n\n        &gt;&gt;&gt; RadixTree().insert(\"word\")\n        &gt;&gt;&gt; RadixTree().index(\"word\")\n        0\n        \"\"\"\n        return self.find(word)[1]\n\n    def __getitem__(self, item: int | str) -&gt; str | int:\n        \"\"\"\n        Retorna a palavra de um índice da árvore.\n        Ou Retorna o índice de uma palavra.\n\n        Args:\n            item (int | str): índice ou palavra.\n\n        Returns:\n            (str | int): a palavra ou índice da palavra na árvore.\n\n        &gt;&gt;&gt; RadixTree().insert(\"word\")\n        &gt;&gt;&gt; RadixTree()[0]\n        \"word\"\n        &gt;&gt;&gt; RadixTree()[\"word\"]\n        0\n        \"\"\"\n        if isinstance(item, int):\n            if item &lt; 0 or item &gt;= self.size:\n                raise IndexError(\"Index out of range\")\n            for word, i in self.all_words().items():\n                if i == item:\n                    return word\n\n        if isinstance(item, str):\n            return self.index(item)\n        \n        return None\n\n    def delete(self, word: str) -&gt; bool:\n        \"\"\"\n        Deleta uma palavra da árvore.\n\n        Args:\n            word (str): palavra a ser deletada.\n\n        Returns:\n            bool: True caso a palavra esteja na árvore e for deletada,\n                  False caso a palavra não esteja na árvore.\n\n        &gt;&gt;&gt; RadixTree().insert(\"word\")\n        &gt;&gt;&gt; RadixTree().delete(\"word\")\n        True\n        \"\"\"\n        if self.root.delete(word):\n            self.size -= 1\n            return True\n        return False\n\n    def print_tree(self) -&gt; None:\n        \"\"\"\n        Imprime a árvore.\n\n        &gt;&gt;&gt; RadixTree().insert_many([\"word1\", \"word2\"])\n        &gt;&gt;&gt; RadixTree().print_tree()\n        --- word\n        ------ 1:   (0)\n        ------ 2:   (1)\n        \"\"\"\n        self.root.print_tree()\n\n    def all_words(self) -&gt; dict:\n        \"\"\"\n        Retorna todas as palavras da árvore numa lista.\n\n        Returns:\n            list[(str, int)]: lista de palavras e índices.\n\n        &gt;&gt;&gt; RadixTree().insert_many([\"word1\", \"word2\"])\n        &gt;&gt;&gt; RadixTree().all_words()\n        [('word1', 0), ('word2', 1)]\n        \"\"\"\n        return self.root.all_words()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        &gt;&gt;&gt; RadixTree()\n        'RadixTree(size=0)'\n        \"\"\"\n        return f\"RadixTree(size={self.size})\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        &gt;&gt;&gt; RadixTree().insert_many([\"word1\", \"word2\"])\n        &gt;&gt;&gt; print(RadixTree())\n        {'word1': 0, 'word2': 1}\n        \"\"\"\n        return self.all_words().__str__()\n\n    def __contains__(self, word: str) -&gt; bool:\n        \"\"\"\n        &gt;&gt;&gt; RadixTree().insert(\"word\")\n        &gt;&gt;&gt; \"word\" in RadixTree()\n        True\n        \"\"\"\n        return self.find(word)[0]\n\n    def __iter__(self):\n        \"\"\"\n        &gt;&gt;&gt; RadixTree().insert_many([\"word1\", \"word2\"])\n        &gt;&gt;&gt; [(word, i) for (word, i) in RadixTree()]\n        [('word1', 0), ('word2', 1)]\n        \"\"\"\n        return iter(self.all_words())\n\n    def __add__(self, word: str) -&gt; None:\n        \"\"\"\n        &gt;&gt;&gt; RadixTree() + \"word\"\n        &gt;&gt;&gt; \"word\" in RadixTree()\n        True\n        \"\"\"\n        self.insert(word)\n\n    def __iadd__(self, word: str):\n        \"\"\"\n        &gt;&gt;&gt; RadixTree() += \"word\"\n        &gt;&gt;&gt; \"word\" in RadixTree()\n        True\n        \"\"\"\n        self.insert(word)\n        return self\n\n    def __sub__(self, word: str) -&gt; bool:\n        \"\"\"\n        &gt;&gt;&gt; RadixTree().insert(\"word\")\n        &gt;&gt;&gt; RadixTree() - \"word\"\n        &gt;&gt;&gt; \"word\" not in RadixTree()\n        True\n        \"\"\"\n        return self.delete(word)\n\n    def __isub__(self, word: str):\n        \"\"\"\n        &gt;&gt;&gt; RadixTree().insert(\"word\")\n        &gt;&gt;&gt; RadixTree() -= \"word\"\n        &gt;&gt;&gt; \"word\" not in RadixTree()\n        True\n        \"\"\"\n        self.delete(word)\n        return self\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        &gt;&gt;&gt; RadixTree().insert_many([\"word1\", \"word2\"])\n        &gt;&gt;&gt; len(RadixTree())\n        2\n        \"\"\"\n        return self.size\n\n    def sort(self, by: str = \"index\") -&gt; list[(str, int)]:\n        \"\"\"\n        &gt;&gt;&gt; RadixTree().insert_many([\"word1\", \"word0\"])\n        &gt;&gt;&gt; RadixTree().sort(by=\"index\")\n        [('word1', 0), ('word0', 1)]\n        &gt;&gt;&gt; RadixTree().sort(by=\"word\")\n        [('word0', 1), ('word1', 0)]\n        \"\"\"\n        words = self.all_words()\n        words = [(word, i) for word, i in words.items()]\n        if by == \"index\":\n            words.sort(key=lambda x: x[1])\n        elif by == \"word\":\n            words.sort(key=lambda x: x[0])\n        return words\n\n\nclass RadixNode:\n    \"\"\"\n    Um nó da árvore de prefixos compacta.\n    \"\"\"\n\n    def __init__(\n        self, prefix: str = \"\", is_leaf: bool = False, index: int = None\n    ) -&gt; None:\n        \"\"\"\n        Cria um nó da árvore de prefixos compacta.\n\n        Args:\n            prefix (str): prefixo do nó.\n            is_leaf (bool): se o nó é uma folha.\n            index (int): índice da palavra adicionada\n\n        &gt;&gt;&gt; RadixNode()\n        &gt;&gt;&gt; RadixNode(\"prefix\")\n        \"\"\"\n        # Mapeamento a partir do primeiro caractere do prefixo do nó\n        self.nodes: dict[str, RadixNode] = {}\n        # Um nó será uma folha se a árvore conter sua palavra\n        self.is_leaf = is_leaf\n        self.prefix = prefix\n        self.index = index\n\n    def _match(self, word: str) -&gt; tuple[str, str, str]:\n        \"\"\"\n        Calcula a substring comum do prefixo do nó e uma palavra.\n\n        Args:\n            word (str): palavra para comparar.\n\n        Returns:\n            (str, str, str): substring comum, prefixo restante, palavra restante.\n\n        &gt;&gt;&gt; RadixNode(\"myprefix\")._match(\"mystring\")\n        ('my', 'prefix', 'string')\n        \"\"\"\n        x = 0\n        for q, w in zip(self.prefix, word):\n            if q != w:\n                break\n\n            x += 1\n\n        return self.prefix[:x], self.prefix[x:], word[x:]\n\n    def insert(self, word: str, index: int) -&gt; None:\n        # Caso 1: Se a palavra for o prefixo do nó\n        # Solução: Definimos o nó atual como folha\n        if self.prefix == word and not self.is_leaf:\n            self.is_leaf = True\n            self.index = index\n\n        # Caso 2: O nó não tem arestas que tenham um prefixo para a palavra\n        # Solução: Criamos uma aresta do nó atual para um novo\n        # contendo a palavra\n        elif word[0] not in self.nodes:\n            self.nodes[word[0]] = RadixNode(word, True, index)\n\n        else:\n            new_node = self.nodes[word[0]]\n            substring, rest_prefix, rest_word = new_node._match(word)\n\n            # Caso 3: O prefixo do nó é igual ao correspondente\n            # Solução: Inserimos a palavra restante no próximo nó\n            if rest_prefix == \"\":\n                self.nodes[substring[0]].insert(rest_word, index)\n\n            # Caso 4: A palavra é maior que a correspondência\n            # Solução: Crie um nó entre os dois nós, altere\n            # prefixos e adicione o novo nó para a palavra restante\n            else:\n                new_node.prefix = rest_prefix\n\n                aux_node = self.nodes[substring[0]]\n                self.nodes[substring[0]] = RadixNode(substring, False, index)\n                self.nodes[substring[0]].nodes[rest_prefix[0]] = aux_node\n\n                if rest_word == \"\":\n                    self.nodes[substring[0]].is_leaf = True\n                    self.nodes[substring[0]].index = index\n                else:\n                    self.nodes[substring[0]].insert(rest_word, index)\n\n    def find(self, word: str) -&gt; tuple[bool, int]:\n        new_node = self.nodes.get(word[0], None)\n        if not new_node:\n            return (False, -1)\n        else:\n            substring, rest_prefix, rest_word = new_node._match(word)\n            # Se houver prefixo restante, a palavra não pode estar na árvore\n            if rest_prefix != \"\":\n                return (False, -1)\n            # Isso se aplica quando a palavra e o prefixo são iguais\n            elif rest_word == \"\":\n                return (True, new_node.index) if new_node.is_leaf else (False, -1)\n            # Temos palavras restantes, então verificamos o próximo nó\n            else:\n                return new_node.find(rest_word)\n\n    def delete(self, word: str) -&gt; bool:\n        new_node = self.nodes.get(word[0], None)\n        if not new_node:\n            return False\n        else:\n            substring, rest_prefix, rest_word = new_node._match(word)\n            # Se houver prefixo restante, a palavra não pode estar na árvore\n            if rest_prefix != \"\":\n                return False, -1\n            # Temos palavras restantes, então verificamos o próximo nó\n            elif rest_word != \"\":\n                return new_node.delete(rest_word)\n            # Se não for uma folha, não precisamos excluir\n            elif not new_node.is_leaf:\n                return False\n            else:\n                # Excluímos os nós se nenhuma aresta sair deles\n                if len(new_node.nodes) == 0:\n                    del self.nodes[word[0]]\n                    # Nós mesclamos o nó atual com seu único filho\n                    if len(self.nodes) == 1 and not self.is_leaf:\n                        merge_node = next(iter(self.nodes.values()))\n                        self.is_leaf = merge_node.is_leaf\n                        self.prefix += merge_node.prefix\n                        self.index = merge_node.index\n                        self.nodes = merge_node.nodes\n                # Se houver mais de uma aresta, nós apenas a marcamos como não-folha\n                elif len(new_node.nodes) &gt; 1:\n                    new_node.is_leaf = False\n                # Se houver 1 aresta, nós a mesclamos com seu filho\n                else:\n                    merge_node = next(iter(new_node.nodes.values()))\n                    new_node.is_leaf = merge_node.is_leaf\n                    new_node.prefix += merge_node.prefix\n                    new_node.index = merge_node.index\n                    new_node.nodes = merge_node.nodes\n                return True\n\n    def print_tree(self, height: int = 0) -&gt; None:\n        if self.prefix != \"\":\n            print(\n                \"---\" * height,\n                (\n                    f\"{self.prefix}:  \\t({self.index})\"\n                    if self.is_leaf\n                    else f\"{self.prefix}\"\n                ),\n            )\n\n        for value in self.nodes.values():\n            value.print_tree(height + 1)\n\n    def all_words(self) -&gt; dict[int, str]:\n        words = {}\n        if self.is_leaf:\n            words[self.prefix] = self.index\n        for value in self.nodes.values():\n            sufixes = value.all_words()\n            for suffix, index in sufixes.items():\n                words[self.prefix + suffix] = index\n        return words"
  },
  {
    "objectID": "Dataframe.html",
    "href": "Dataframe.html",
    "title": "Trabalho Prático I - Manipulação de Sequências",
    "section": "",
    "text": "Notebook principal contendo o fluxo principal de codificação e decodificação. O processo é o seguinte:\n\nLê o arquivo de entrada da pasta tests;\nFaz a codificação, calculando seu tempo de computação;\nFaz a comparação entre os tamanhos do arquivo original e o resultado comprimido, os cálculos de taxa de compressão e tempo relativo ao tamanho da entrada;\nGrava os resultados no arquivo out.csv.\n\n\n\n\nContém o codificador e decodificador nas classes lzw_encodere lzw_decoder, ambos criam um dicionário que relaciona substrings com inteiros.\n\nO encoder lê um texto em ASCII ou uma string binária e cria uma lista de inteiros, que são os códigos.\nEsses códigos são a entrada para o decoder que os convertem para a string original do texto.\n\n\n\n\nA estrutura de dados para a criação do dicionário. O tipo de árvore é a RadixTree ou árvore Trie compacta.\n\n &gt; Exemplos de Radix Tree\n\n\n\nUm conjunto de funções auxiliares como conversão de String em ASCII para string binária, compressão e descompressão da lista de códigos de inteiro para binário.\n\n\n\nContém os resultados dos testes feitos, que contém:\n\nNome do arquivo de teste;\nTamanho do arquivo;\nTamanho dos códigos;\nTamanho do dicionário;\nA quantidade de bits por código usado;\nTaxa de compressão;\nTempo de compressão;\nTempo relativo ao tamanho do arquivo.\n\n\n\n\nA pasta onde contém o conjunto de arquivos de entrada para a realização de testes."
  },
  {
    "objectID": "Dataframe.html#main.ipynb",
    "href": "Dataframe.html#main.ipynb",
    "title": "Trabalho Prático I - Manipulação de Sequências",
    "section": "",
    "text": "Notebook principal contendo o fluxo principal de codificação e decodificação. O processo é o seguinte:\n\nLê o arquivo de entrada da pasta tests;\nFaz a codificação, calculando seu tempo de computação;\nFaz a comparação entre os tamanhos do arquivo original e o resultado comprimido, os cálculos de taxa de compressão e tempo relativo ao tamanho da entrada;\nGrava os resultados no arquivo out.csv."
  },
  {
    "objectID": "Dataframe.html#lzw.py",
    "href": "Dataframe.html#lzw.py",
    "title": "Trabalho Prático I - Manipulação de Sequências",
    "section": "",
    "text": "Contém o codificador e decodificador nas classes lzw_encodere lzw_decoder, ambos criam um dicionário que relaciona substrings com inteiros.\n\nO encoder lê um texto em ASCII ou uma string binária e cria uma lista de inteiros, que são os códigos.\nEsses códigos são a entrada para o decoder que os convertem para a string original do texto."
  },
  {
    "objectID": "Dataframe.html#trie.py",
    "href": "Dataframe.html#trie.py",
    "title": "Trabalho Prático I - Manipulação de Sequências",
    "section": "",
    "text": "A estrutura de dados para a criação do dicionário. O tipo de árvore é a RadixTree ou árvore Trie compacta.\n\n &gt; Exemplos de Radix Tree"
  },
  {
    "objectID": "Dataframe.html#functions.py",
    "href": "Dataframe.html#functions.py",
    "title": "Trabalho Prático I - Manipulação de Sequências",
    "section": "",
    "text": "Um conjunto de funções auxiliares como conversão de String em ASCII para string binária, compressão e descompressão da lista de códigos de inteiro para binário."
  },
  {
    "objectID": "Dataframe.html#out.csv",
    "href": "Dataframe.html#out.csv",
    "title": "Trabalho Prático I - Manipulação de Sequências",
    "section": "",
    "text": "Contém os resultados dos testes feitos, que contém:\n\nNome do arquivo de teste;\nTamanho do arquivo;\nTamanho dos códigos;\nTamanho do dicionário;\nA quantidade de bits por código usado;\nTaxa de compressão;\nTempo de compressão;\nTempo relativo ao tamanho do arquivo."
  },
  {
    "objectID": "Dataframe.html#tests",
    "href": "Dataframe.html#tests",
    "title": "Trabalho Prático I - Manipulação de Sequências",
    "section": "",
    "text": "A pasta onde contém o conjunto de arquivos de entrada para a realização de testes."
  }
]