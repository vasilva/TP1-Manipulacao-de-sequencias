---
title: "Trabalho Prático I - Manipulação de Sequências"
author: "Vinícius Alexandre da Silva"
toc: true
format: 
  html:
    code-fold: true
    html-math-method: katex
jupyter: python3
---

# Arquivos

## [main.ipynb](https://github.com/vasilva/TP1-Manipulacao-de-sequencias/blob/main/main.ipynb):
Notebook principal contendo o fluxo principal de codificação e decodificação. O processo é o seguinte:

* Lê o arquivo de entrada da pasta [tests](https://github.com/vasilva/TP1-Manipulacao-de-sequencias/tree/main/tests);
* Faz a codificação, calculando seu tempo de computação;
* Faz a comparação entre os tamanhos do arquivo original e o resultado comprimido, os cálculos de taxa de compressão e tempo relativo ao tamanho da entrada;
* Grava os resultados no arquivo [out.csv](https://github.com/vasilva/TP1-Manipulacao-de-sequencias/tree/main/out.csv).

## [lzw.py](https://github.com/vasilva/TP1-Manipulacao-de-sequencias/blob/main/lzw.py):
Contém o codificador e decodificador nas classes `lzw_encoder`e `lzw_decoder`, ambos criam um dicionário que relaciona substrings com inteiros.

* O `encoder` lê um texto em ASCII ou uma string binária e cria uma lista de inteiros, que são os códigos.
* Esses códigos são a entrada para o `decoder` que os convertem para a string original do texto.

## [trie.py](https://github.com/vasilva/TP1-Manipulacao-de-sequencias/blob/main/trie.py):
A estrutura de dados para a criação do dicionário. O tipo de árvore é a `RadixTree` ou árvore Trie compacta.

![](https://imgur.com/ydFCuZU)

![Exemplos de Radix Tree](https://imgur.com/HlML7fZ)

## [functions.py](https://github.com/vasilva/TP1-Manipulacao-de-sequencias/blob/main/Str_functions.py):
Um conjunto de funções auxiliares como conversão de String em ASCII para string binária, compressão e descompressão da lista de códigos de inteiro para binário.

## [out.csv](https://github.com/vasilva/TP1-Manipulacao-de-sequencias/tree/main/out.csv):
Contém os resultados dos testes feitos, que contém:

* Nome do arquivo de teste;
* Tamanho do arquivo;
* Tamanho dos códigos;
* Tamanho do dicionário;
* A quantidade de bits por código usado;
* Taxa de compressão;
* Tempo de compressão;
* Tempo relativo ao tamanho do arquivo.

## [tests](https://github.com/vasilva/TP1-Manipulacao-de-sequencias/tree/main/tests):
A pasta onde contém o conjunto de arquivos de entrada para a realização de testes.

# Análise de Dados

```{python}
#| label: Dataframe_1
#| fig-cap: "Dados coletados nos testes"
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

df = pd.read_csv("out.csv")
df
```
Nesta tabela temos os dados dos testes rodados.

* `Arquivo`: O nome do arquivo de entrada;
* `Tamanho original (bits)`: Tamanho do arquivo;
* `Tamanho comprimido (bits)`: Tamanho dos códigos;
* `Tamanho dicionário`: Quantidade de elementos no dicionário;
* `Qtd de bits por código`: Número de bits para os códigos, calculado por $bitlength(max(code))$;
* `Taxa de compressão`: A razão entre os tamanhos do arquivo e dos códigos - $Tamanho Original / Tamanho Comprimido$;
* `Tempo de compressão`: Tempo de processamento, para cada arquivo foram feitas 20 compressões, para se ter um tempo médio com mais confiabilidade;
* `Tempo relativo (ms/kB)`: Tempo de compressão pelo tamanho do arquivo de entrada.

```{python}
# | label: Graph_1
# | fig-cap: "O tamanho do dicionário tende a crescer linearmente com o tamanho do arquivo de entrada."
plt.figure(figsize=(8, 6))
plt.scatter(
    df["Tamanho Dicionário"],
    df["Tamanho original (bits)"],
    alpha=0.7,
    edgecolors="k",
)
plt.grid(True)
plt.xlabel("Tamanho Dicionário")
plt.ylabel("Tamanho Original (bits)")
plt.title("Tamanho Original vs Tamanho Dicionário")
plt.show()
```

```{python}
#| label: Graph_2
#| fig-cap: "Também há um crescimento linear com a saída comprimida."
plt.figure(figsize=(8, 6))
plt.scatter(
    df["Tamanho Dicionário"],
    df["Tamanho comprimido (bits)"],
    alpha=0.7,
    edgecolors="k",
)
plt.grid(True)
plt.xlabel("Tamanho Dicionário")
plt.ylabel("Tamanho comprimido (bits)")
plt.title("Tamanho comprimido vs Tamanho Dicionário")
plt.show()
```

```{python}
# | label: Histograms
# | fig-cap: "Esses são os tempos (ms) relativos ao tamanho do arquivo (kB), que tendem a serem consistentes, exceto alguns casos atípicos, que podem ser atribuídos a forma de medição do tempo."
def bootstrap_mean(data, num_samples=10000):
    n = len(data)
    sample_means = np.zeros(num_samples)
    for i in range(num_samples):
        sample = np.random.choice(data, size=n, replace=True)
        sample_means[i] = np.mean(sample)
    return sample_means


fig, ax = plt.subplots(figsize=(6, 12), ncols=2, nrows=4)
fig.suptitle(f"Histograma de Tempo Relativo por Arquivo")
for i, file in enumerate(df["Arquivo"].unique()):
    time = df.loc[(df["Arquivo"] == file), "Tempo Relativo (ms/kB)"].values
    sample_means = bootstrap_mean(time)
    ax[i // 2, i % 2].hist(time, bins=20, alpha=0.7, edgecolor="k")
    ax[i // 2, i % 2].axvline(np.mean(sample_means), color="r", linestyle="--")
    ax[i // 2, i % 2].set_title(file)
    ax[i // 2, i % 2].set_xlabel("Tempo Relativo (ms/kB)")
    ax[i // 2, i % 2].set_ylabel("Frequência")
    ax[i // 2, i % 2].set_xlim(0, 30)
plt.tight_layout()
plt.show()
```

```{python}
# | label: Dataframe_2
# | fig-cap: "Dados médios"
tempos_relativos = (
    df[
        [
            "Arquivo",
            "Taxa de compressão",
            "Tamanho original (bits)",
            "Tempo Relativo (ms/kB)",
        ]
    ]
    .groupby("Arquivo")
    .mean()
)
tempos_relativos.reset_index(inplace=True)
tempos_relativos
```

```{python}
#| label: Graph_3
#| fig-cap: "Com exceção de arquivos muito pequenos, o tempo relativo tende a ser constante com o tamanho do arquivo."
plt.figure(figsize=(8, 6))
plt.scatter(
    tempos_relativos["Tamanho original (bits)"],
    tempos_relativos["Tempo Relativo (ms/kB)"],
    alpha=0.7,
    edgecolors="k",
)
plt.grid(True)
plt.xlabel("Tamanho original (bits)")
plt.ylabel("Tempo Relativo (ms/kB)")
plt.title("Tempo Relativo vs Tamanho original")
plt.show()
```

```{python}
# | label: Graph_4
# | fig-cap: "`ex (2).txt` foi intencionalmente criado para ter uma alta taxa de compressão. `ex (1).txt` é um arquivo muito pequeno para ter compressão efetiva. Os outros arquivos têm uma taxa de compressão próxima de 2."
plt.figure(figsize=(8, 6))
plt.scatter(
    tempos_relativos["Tamanho original (bits)"],
    tempos_relativos["Taxa de compressão"],
    alpha=0.7,
    edgecolors="k",
)
plt.grid(True)
plt.xlabel("Tamanho original (bits)")
plt.ylabel("Taxa de compressão")
plt.title("Tamanho Original vs Taxa de compressão")
plt.show()
```